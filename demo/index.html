<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Weather Forecast Card - Development Test</title>
    <style>
      :root {
        --card-background-color: #1c1c1c;
        --ha-card-border-color: rgba(255, 255, 255, 0.05);
        --ha-box-shadow-l:
          0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        --primary-color: #009ac7;
        --primary-text-color: #fff;
        --secondary-text-color: #929292;
        --ha-font-size-3xl: 28px;
        --ha-font-size-2xl: 24px;
        --ha-font-size-xl: 20px;
        --ha-font-size-l: 16px;
        --ha-font-size-m: 14px;
        --ha-line-height-condensed: 1.2;
        --ha-card-border-radius: 20px;
        --ha-card-background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.1) 20%,
          rgba(0, 0, 0, 0.01) 100%
        );
        font-family: "Roboto", "Noto", sans-serif;
        color: var(--primary-text-color);
        --card-padding: 24px;
        --state-icon-color: #44739e;
      }
      .light-theme {
        --card-background-color: #fff;
        --primary-text-color: #141414;
        --secondary-text-color: #5e5e5e;
        --ha-card-background: #fff;
        color: var(--primary-text-color);
      }

      body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 32px;
        font-weight: 700;
        margin: 0 0 8px 0;
        letter-spacing: -0.5px;
        color: #fff;
      }
      h3 {
        color: #cecece;
        font-size: 20px;
        font-weight: 400;
        margin: 0 0 24px 0;
        text-align: center;
      }
      .features {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .feature {
        font-size: 14px;
        color: #cecece;
        display: flex;
        gap: 8px;
        text-align: left;
        white-space: nowrap;
      }
      .feature svg {
        flex-shrink: 0;
        width: 18px;
        height: 18px;
        stroke: dodgerblue;
      }
      .view {
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100vw;
        background: url("./background.png") no-repeat center center;
        background-size: cover;
      }
      .dashboard {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        gap: 30px;
        flex: 0 0 auto;
      }
      .intro {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        max-width: 380px;
      }
      .tap-indicator {
        position: absolute;
        width: 60px;
        height: 60px;
        border: 3px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
        z-index: 1000;
      }
      .tap-indicator.active {
        animation: tap-ripple 0.6s ease-out;
      }
      .tap-indicator.hold {
        animation: hold-pulse 1.2s ease-out;
      }
      .tap-indicator.hold::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -50%) scale(0);
        animation: hold-fill 1.2s ease-out;
      }
      @keyframes tap-ripple {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(0.5);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1.5);
        }
      }
      @keyframes hold-pulse {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(0.8);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1.2);
        }
      }
      @keyframes hold-fill {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0.8;
        }
        70% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0.5;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }
      .scroll-indicator {
        position: absolute;
        width: 50px;
        height: 50px;
        pointer-events: none;
        opacity: 0;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .scroll-indicator svg {
        width: 100%;
        height: 100%;
        fill: rgba(255, 255, 255, 0.9);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        transition: transform 0.2s ease;
      }
      .scroll-indicator.reverse svg {
        transform: scaleX(-1);
      }
      .scroll-indicator.active {
        animation: scroll-slide 0.8s ease-out;
      }
      @keyframes scroll-slide {
        0% {
          opacity: 1;
          transform: translateX(0);
        }
        100% {
          opacity: 0;
          transform: translateX(30px);
        }
      }
      .scroll-indicator.reverse.active {
        animation: scroll-slide-reverse 0.8s ease-out;
      }
      @keyframes scroll-slide-reverse {
        0% {
          opacity: 1;
          transform: translateX(0);
        }
        100% {
          opacity: 0;
          transform: translateX(-30px);
        }
      }
      .demo-card-container {
        display: block;
        box-sizing: border-box;
        box-shadow: 0px 0px 10px 5px rgba(0, 0, 0, 0.1);
        border-radius: 20px;
      }
      .theme-toggle {
        position: absolute;
        top: 24px;
        right: 24px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 8px 16px;
        border-radius: 20px;
        color: white;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 1001;
        transition: all 0.2s ease;
      }
      .theme-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .demo-card {
        display: block;
        width: 550px;
        background: var(--ha-card-background);
        backdrop-filter: blur(20px) saturate(110%) brightness(90%);
        border-radius: 20px;
        border-width: 1px;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.05);
        box-shadow:
          0 8px 32px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.5),
          inset 0 -1px 0 rgba(255, 255, 255, 0.1),
          inset 0 0 2px 1px rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="view">
      <button class="theme-toggle" id="theme-toggle">
        <svg
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <circle cx="12" cy="12" r="5" />
          <path
            d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M17.66 6.34l1.42-1.42"
          />
        </svg>
        <span>Toggle Theme</span>
      </button>
      <div class="dashboard">
        <div class="intro">
          <h1>Weather Forecast Card</h1>
          <h3>For Home Assistant</h3>
          <div class="features">
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Visualize more forecast data in a scrollable layout
            </div>
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Toggle between hourly and daily forecasts with a single tap
            </div>
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Visualize forecast trend charts with interactive attribute
              selector
            </div>
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Aggregate multiple hours of forecast data for easier viewing
            </div>
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Emphasize important conditions with visual effects
            </div>
            <div class="feature">
              <svg
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Card editor and more!
            </div>
          </div>
        </div>
        <div class="demo-card-container">
          <weather-forecast-card class="demo-card"></weather-forecast-card>
        </div>
        <div class="tap-indicator" id="tap-indicator"></div>
        <div class="scroll-indicator" id="scroll-indicator">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z" />
          </svg>
        </div>
      </div>
    </div>
    <script type="module" src="../src/index.ts"></script>
    <script type="module">
      import { MockHass } from "../test/mocks/index.ts";

      let theme = "dark";
      const mockHass = new MockHass({
        darkMode: theme === "dark",
        currentCondition: "partlycloudy",
      });

      let hass = mockHass.getHass();

      const demoMode = "toggle_and_scroll"; // 'condition_effects' | 'toggle_and_scroll' | 'none'

      const updateTheme = () => {
        const card = document.querySelector(".demo-card");
        if (theme === "light") {
          card.classList.add("light-theme");
          document.body.classList.add("light-theme");
        } else {
          card.classList.remove("light-theme");
          document.body.classList.remove("light-theme");
        }
        mockHass.setDarkMode(theme === "dark");
        hass = mockHass.getHass();
        card.hass = hass;
      };

      updateTheme();

      document.getElementById("theme-toggle").addEventListener("click", () => {
        theme = theme === "dark" ? "light" : "dark";
        updateTheme();
      });

      customElements.whenDefined("weather-forecast-card").then(() => {
        const card = document.querySelector(".demo-card");

        card.setConfig({
          type: "custom:weather-forecast-card",
          entity: "weather.demo",
          name: "Home",
          show_condition_effects: false,
          current: {
            show_attributes: ["visibility", "apparent_temperature"],
          },
          forecast: {
            mode: "chart",
            extra_attribute: "wind_direction",
            hourly_group_size: 2,
            show_sun_times: demoMode !== "condition_effects",
            use_color_thresholds: true,
          },
        });

        card.hass = hass;

        const rotateConditionsDemo = () => {
          const conditions = [
            "sunny",
            "snowy",
            "rainy",
            "lightning-rainy",
            "clear-night",
          ];
          let index = 0;

          setInterval(() => {
            mockHass.setCurrentConditions(conditions[index]);
            card.hass = mockHass.getHass();

            index = (index + 1) % conditions.length;
          }, 5000);
        };

        const toggleAndScrollDemo = () => {
          const scrollContainer = card.shadowRoot?.querySelector(
            ".wfc-scroll-container"
          );

          if (scrollContainer) {
            console.log("Starting demo sequence");

            const tapIndicator = document.getElementById("tap-indicator");
            const scrollIndicator = document.getElementById("scroll-indicator");

            // Function to show tap indicator at element center
            const showTapIndicator = (element) => {
              const rect = element.getBoundingClientRect();
              const x = rect.left + rect.width / 2;
              const y = rect.top + rect.height / 2;

              tapIndicator.style.left = `${x}px`;
              tapIndicator.style.top = `${y}px`;
              tapIndicator.classList.remove("active", "hold");

              // Trigger reflow to restart animation
              void tapIndicator.offsetWidth;
              tapIndicator.classList.add("active");
            };

            // Function to show hold indicator at element center
            const showHoldIndicator = (element) => {
              const rect = element.getBoundingClientRect();
              const x = rect.left + rect.width / 2;
              const y = rect.top + rect.height / 2;

              tapIndicator.style.left = `${x}px`;
              tapIndicator.style.top = `${y}px`;
              tapIndicator.classList.remove("active", "hold");

              // Trigger reflow to restart animation
              void tapIndicator.offsetWidth;
              tapIndicator.classList.add("hold");
            };

            // Function to show scroll indicator
            const showScrollIndicator = (element, reverse = false) => {
              const rect = element.getBoundingClientRect();
              const indicatorWidth = 50; // Width of the indicator
              const edgeOffset = 30; // Distance from edge
              // Position symmetrically from edges
              const x = reverse
                ? rect.left + edgeOffset
                : rect.right - edgeOffset - indicatorWidth;
              const y = rect.top + rect.height / 3;

              scrollIndicator.style.left = `${x}px`;
              scrollIndicator.style.top = `${y}px`;
              scrollIndicator.classList.remove("active", "reverse");

              if (reverse) {
                scrollIndicator.classList.add("reverse");
              }

              // Trigger reflow to restart animation
              void scrollIndicator.offsetWidth;
              scrollIndicator.classList.add("active");
            };

            const getChartComponent = () => {
              return card.shadowRoot?.querySelector("wfc-forecast-chart");
            };

            const getAttributeSelector = () => {
              const chart = getChartComponent();
              return chart?.querySelector("wfc-chart-attribute-selector");
            };

            const selectAttribute = (attributeValue) => {
              const selector = getAttributeSelector();
              if (!selector) return false;

              const dropdown = selector.shadowRoot?.querySelector(".dropdown");
              if (!dropdown) return false;

              const items = dropdown.querySelectorAll(".menu-item");
              for (const item of items) {
                const itemContent = item.querySelector(".item-content span");
                if (
                  attributeValue === "humidity" &&
                  itemContent?.textContent?.toLowerCase().includes("humidity")
                ) {
                  showTapIndicator(item);
                  item.click();
                  return true;
                } else if (attributeValue === "temperature_and_precipitation") {
                  showTapIndicator(items[0]);
                  items[0].click();
                  return true;
                }
              }
              return false;
            };

            const holdForecast = () => {
              const forecastComponent = getChartComponent();
              if (!forecastComponent) return;

              const scrollContainer = forecastComponent.querySelector(
                ".wfc-scroll-container"
              );
              if (!scrollContainer) return;

              showHoldIndicator(scrollContainer);

              // Dispatch hold action event
              const holdEvent = new CustomEvent("action", {
                bubbles: true,
                composed: true,
                detail: { action: "hold" },
              });
              scrollContainer.dispatchEvent(holdEvent);
            };

            const clickForecast = () => {
              const forecastComponent =
                card.shadowRoot?.querySelector("wfc-forecast-chart");

              if (forecastComponent) {
                const header = forecastComponent.querySelector(
                  ".wfc-forecast-chart-header"
                );
                const slots = header?.querySelectorAll(".wfc-forecast-slot");
                const canvas =
                  forecastComponent.querySelector("#forecast-canvas");

                if (slots && slots.length >= 5 && canvas) {
                  const slotToClick = slots[4];
                  showTapIndicator(slotToClick);

                  const slotIndex = parseInt(slotToClick.dataset.index, 10);
                  const slotRect = slotToClick.getBoundingClientRect();
                  const canvasRect = canvas.getBoundingClientRect();

                  const slotCenterX = slotRect.left + slotRect.width / 2;
                  const offsetX = slotCenterX - canvasRect.left;
                  const offsetY = canvasRect.height / 2;

                  const pointerEvent = new PointerEvent("pointerdown", {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: slotCenterX,
                    clientY: canvasRect.top + offsetY,
                    isPrimary: true,
                  });

                  // Override offsetX/offsetY since synthetic events don't calculate them
                  Object.defineProperty(pointerEvent, "offsetX", {
                    value: offsetX,
                  });
                  Object.defineProperty(pointerEvent, "offsetY", {
                    value: offsetY,
                  });

                  canvas.dispatchEvent(pointerEvent);

                  const eventInit = {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: slotCenterX,
                    clientY: canvasRect.top + offsetY,
                  };

                  slotToClick.dispatchEvent(
                    new MouseEvent("mousedown", eventInit)
                  );
                  slotToClick.dispatchEvent(
                    new MouseEvent("mouseup", eventInit)
                  );
                  slotToClick.dispatchEvent(new MouseEvent("click", eventInit));
                }
              }
            };

            let step = 0;

            setInterval(() => {
              switch (step) {
                case 0:
                  // Click forecast
                  clickForecast();
                  step = 1;
                  break;
                case 1:
                  // Hold to open attribute dropdown
                  holdForecast();
                  step = 2;
                  break;
                case 2:
                  // Select humidity
                  selectAttribute("humidity");
                  step = 3;
                  break;
                case 3:
                  // Hold again to open dropdown
                  holdForecast();
                  step = 4;
                  break;
                case 4:
                  // Select temperature and precipitation
                  selectAttribute("temperature_and_precipitation");
                  step = 5;
                  break;
                case 5:
                  // Click forecast to reset/close
                  clickForecast();
                  step = 0;
                  break;
              }
            }, 2500);
          } else {
            console.error(
              "Could not find scroll container or forecast container"
            );
          }
        };

        if (demoMode === "toggle_and_scroll") {
          setTimeout(toggleAndScrollDemo, 2000);
        } else if (demoMode === "condition_effects") {
          setTimeout(rotateConditionsDemo, 2000);
        }
      });
    </script>
  </body>
</html>
